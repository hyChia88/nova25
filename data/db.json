{
  "USER_PROFILE": {
    "major": "computational deisgn",
    "career_goal": "software engineer",
    "profile": [
      "User studied architecture; has domain knowledge.",
      "Studied discrete math; weaker in software construction.",
      "Wants to learn more 3D generation methods."
    ]
  },
  "COURSES": {
    "SOFTWARE_CONSTRUCTION": {
      "sc-2025-01-11-001": {
        "title": "Software Construction Overview",
        "content": [
          "The course focuses on principles related to objects, design, and concurrency in software construction. It includes assignments, exams, and collaborative learning activities."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-002": {
        "title": "Learning Goals",
        "content": [
          "The goals include understanding the decorator pattern, applying software design patterns, and improving confidence in reasoning about software design problems."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-003": {
        "title": "Decorator Pattern Introduction",
        "content": [
          "The decorator pattern allows for adding responsibilities to objects dynamically at runtime. It offers more flexibility than inheritance by enabling the composition of behaviors without large, complex class hierarchies."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-004": {
        "title": "Limitations of Inheritance",
        "content": [
          "Inheritance can lead to issues such as combinatorial explosion and massive code replication when trying to extend data structures with multiple, overlapping features."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-005": {
        "title": "Stack Extensions Example",
        "content": [
          "The need for composable stack extensions (e.g., UndoStack, SecureStack) demonstrates the limitations of inheritance in handling complex feature combinations efficiently."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-006": {
        "title": "Decorator Pattern Implementation",
        "content": [
          "The pattern defines a decorator object that implements an extended object interface, allowing additional functionality to be performed before or after forwarding requests, thereby avoiding large class hierarchies."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-007": {
        "title": "Java Util Collections Decorators",
        "content": [
          "Java's util.Collections library provides helper methods like unmodifiableList and synchronizedList that apply the decorator pattern to make collections immutable or thread-safe."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-008": {
        "title": "Trouble Game Rules Overview",
        "content": [
          "Trouble is a board game for 2-4 players where pieces move clockwise based on dice rolls. Specific rolls are needed to exit home and reach the finish zone, with the goal of moving all pieces to the finish zone first."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-01-11-009": {
        "title": "Design Challenges",
        "content": [
          "Successful design involves making choices; there is no single correct design, but rather many possible incorrect designs. Understanding patterns and design principles assists in making informed decisions."
        ],
        "timestamp": "2025-01-11T00:00:00Z",
        "freshness": 0.18
      },
      "sc-2025-08-11-001": {
        "title": "Formalizing Concurrency",
        "content": [
          "Concurrency involves multiple threads running at the same time, but not necessarily executing in parallel. It's important to differentiate concurrency from parallelism to avoid misconceptions."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-002": {
        "title": "Thread Basics",
        "content": [
          "A thread is a flow of execution in a program, where tasks are performed in sequence. Threads can be created, started, blocked, and terminated, and they share the same address space within a program."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-003": {
        "title": "Java Thread Implementations",
        "content": [
          "The `java.lang.Runnable` interface represents a task, while the `java.lang.Thread` class can execute a task in a separate thread. This allows for multithreaded operations in Java applications."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-004": {
        "title": "Reasons to Use Threads",
        "content": [
          "Threads improve performance by allowing for non-blocking activities and taking advantage of multi-core processors. They are essential in modern computing environments to ensure efficient resource utilization."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-005": {
        "title": "Concurrency Hazards",
        "content": [
          "Concurrent programming introduces safety risks such as race conditions, deadlocks, and liveliness failures. Proper synchronization strategies are required to mitigate these risks."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-006": {
        "title": "Thread Safety",
        "content": [
          "Thread safety means that a class behaves correctly when accessed by multiple threads. This requires proper synchronization to prevent state corruption, visibility failures, and deadlocks."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-007": {
        "title": "Immutability in Concurrency",
        "content": [
          "Immutable objects are inherently thread-safe because their state cannot be changed after creation. Designing programs with immutable objects simplifies concurrency management."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-008": {
        "title": "Synchronization Techniques",
        "content": [
          "Synchronization ensures that shared resources are accessed in a controlled manner. Java provides intrinsic locks and synchronized methods as tools for concurrency control."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-009": {
        "title": "Atomicity",
        "content": [
          "An operation is atomic if it is indivisible, with no intermediate states visible to other threads. While some simple actions like reading and writing int variables are atomic in Java, others, like increment operations, are not."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-010": {
        "title": "Aliasing and Defensive Copies",
        "content": [
          "Aliasing occurs when multiple references point to the same mutable data, potentially causing race conditions. Defensive copying can mitigate this by ensuring immutable data structures are maintained."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "sc-2025-08-11-011": {
        "title": "Performance Implications of Immutability",
        "content": [
          "While immutability offers safety benefits, it can lead to performance overhead due to object copies. Strategies such as using mutable helpers (e.g., StringBuilder for Strings) can balance safety with efficiency."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "so-2025-11-08-001": {
        "title": "Design for Reuse",
        "content": [
          "Designing for reuse is essential in software engineering to enhance code maintainability and extensibility. This involves using composition and inheritance appropriately to achieve code reuse."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-002": {
        "title": "Behavioral Subtyping",
        "content": [
          "Behavioral subtyping ensures that a subclass can be used in place of a superclass. It maintains the expectations of the superclass and allows more specific but compatible behavior in subclasses."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-003": {
        "title": "Inheritance vs. Composition",
        "content": [
          "Inheritance allows for code reuse by creating a subclass from an existing superclass. Composition involves the use of objects in other classes to achieve reuse. Each has benefits and drawbacks, and their use should be context-dependent."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-004": {
        "title": "Template Method Pattern",
        "content": [
          "The template method pattern uses inheritance to define a basic algorithm structure in a superclass and allows subclasses to define specific behaviors without changing the algorithm's structure."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-005": {
        "title": "Strategy Pattern",
        "content": [
          "This pattern uses delegation to allow the algorithm to vary independently from the context in which it's used. Strategy objects are reusable and can be swapped to offer flexibility."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-006": {
        "title": "Class Hierarchy",
        "content": [
          "Classes in object-oriented programming are organized in a hierarchy where a class can inherit characteristics from parent classes. Understanding these relationships is pivotal in designing robust systems."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-007": {
        "title": "Fragile Base Class Problem",
        "content": [
          "This problem arises when changes to a superclass unexpectedly affect subclasses. It underscores the risks of tightly coupling subclasses to the internal details of their superclasses."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-008": {
        "title": "Dynamic Dispatch",
        "content": [
          "In Java, dynamic dispatch allows method calls to be resolved at runtime depending on the object's type, facilitating polymorphic behavior."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-009": {
        "title": "Delegation for Reuse",
        "content": [
          "Delegation involves an object relying on another for specific functionality, promoting reuse. It supports more flexible designs by separating responsibilities among different objects."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-010": {
        "title": "Interface Inheritance",
        "content": [
          "Interface inheritance allows classes to implement multiple interfaces, offering a way to ensure that an object offers specific behavior without dictating how it should be achieved."
        ],
        "timestamp": "2025-11-08T17:21:50.469506Z",
        "freshness": 0.0
      },
      "so-2025-11-08-011": {
        "title": "Java Language Features for Inheritance",
        "content": [
          "Java supports inheritance with features like final to restrict inheritance and methods, and abstract classes that require subclass implementation."
        ],
        "timestamp": "2025-11-08T17:23:58.547559Z",
        "freshness": 0.0
      },
      "so-2025-11-08-012": {
        "title": "Delegation for Code Reuse",
        "content": [
          "Delegation involves an object relying on another for some functionality, promoting code reuse and modular design by separating responsibilities."
        ],
        "timestamp": "2025-11-08T17:23:58.547559Z",
        "freshness": 0.0
      },
      "so-2025-11-08-013": {
        "title": "Liskov Substitution Principle",
        "content": [
          "This principle states that objects of the superclass should be replaceable with objects of a subclass without affecting the correctness of the program."
        ],
        "timestamp": "2025-11-08T17:23:58.547559Z",
        "freshness": 0.0
      },
      "so-2025-11-08-014": {
        "title": "Class Hierarchies in OOP",
        "content": [
          "Object-oriented programming organizes classes into hierarchies, enabling polymorphism and code reuse, but demands careful design consideration to prevent excessive coupling."
        ],
        "timestamp": "2025-11-08T17:23:58.547559Z",
        "freshness": 0.0
      },
      "so-2025-11-08-015": {
        "title": "Principles of Software Construction",
        "content": [
          "Focuses on object-oriented design and concurrency, with a specific look into inheritance and delegation."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-016": {
        "title": "Design Reuse",
        "content": [
          "Design for reuse is crucial and can be achieved through composition and inheritance, each having unique benefits and challenges."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-017": {
        "title": "Array-Based Integer List",
        "content": [
          "An example implementation of an integer list in Java demonstrates techniques of reuse through interfaces, illustrating practical design principles."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-018": {
        "title": "Inheritance in Java",
        "content": [
          "Inheritance allows a subclass to extend a superclass, adding new methods and fields while potentially overriding existing ones with compatible signatures."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-019": {
        "title": "Composition and Delegation",
        "content": [
          "These are alternatives to inheritance, promoting reuse through object interaction and delegation of responsibilities, leading to more modular and testable design."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-020": {
        "title": "Dynamic Dispatch in Java",
        "content": [
          "Java determines method execution at runtime based on the object’s dynamic class, enabling polymorphic behavior."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-021": {
        "title": "Class Hierarchies and Inheritance",
        "content": [
          "Class hierarchies form the backbone of object-oriented languages, supporting polymorphism and code reuse but often at the expense of tight coupling."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-022": {
        "title": "LoggingList Inheritance Trade-Offs",
        "content": [
          "Inheriting from IntArrayList for LoggingList implementation shows reuse benefits but highlights the 'fragile base class' problem due to tight coupling and implementation dependence."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-023": {
        "title": "Language Features for Enforcing Types",
        "content": [
          "Java and TypeScript offer various language features to enforce inheritance rules and promote type safety, such as final classes and methods."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-024": {
        "title": "Decisions in Inheritance",
        "content": [
          "Design decisions around inheritance vs. composition should consider 'is-a' relationships, the potential for code reuse, and the risk of over-coupling."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-025": {
        "title": "Subtyping vs. Inheritance",
        "content": [
          "While inheritance focuses on code reuse through polymorphism, subtyping is purely a matter of substitutability, ensuring consistent behavior across types."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-026": {
        "title": "Java and TypeScript Inheritance",
        "content": [
          "Both languages support inheritance with unique features and constraints, offering flexibility while maintaining type integrity."
        ],
        "timestamp": "2025-11-08T17:25:56.520386Z",
        "freshness": 0.0
      },
      "so-2025-11-08-027": {
        "title": "Class Hierarchy Basics",
        "content": [
          "Explains the structure and terminology of class hierarchies, including concepts like superclass, subclass, and dynamic dispatch semantics."
        ],
        "timestamp": "2025-11-08T17:29:55.121689Z",
        "freshness": 0.0
      },
      "so-2025-11-08-028": {
        "title": "Interface Inheritance in Java and TypeScript",
        "content": [
          "Covers interface inheritance, allowing one interface to inherit methods from another, which is important for creating cohesive and extendable APIs."
        ],
        "timestamp": "2025-11-08T17:29:55.121689Z",
        "freshness": 0.0
      },
      "so-2025-11-08-029": {
        "title": "Use of Delegation",
        "content": [
          "Emphasizes how delegation can extend functionality and promote code reuse by allowing one object to rely on another object for specific behaviors."
        ],
        "timestamp": "2025-11-08T17:29:55.121689Z",
        "freshness": 0.0
      },
      "so-2025-11-08-030": {
        "title": "Design Considerations for Inheritance",
        "content": [
          "Outlines best practices for using inheritance, such as documenting method contracts and considering alternative approaches like composition and delegation."
        ],
        "timestamp": "2025-11-08T17:29:55.121689Z",
        "freshness": 0.0
      },
      "so-2025-11-08-031": {
        "title": "Dynamic Dispatch Semantics",
        "content": [
          "Covers the process in object-oriented languages where the method to be invoked on an object is determined at runtime, based on the object's dynamic class."
        ],
        "timestamp": "2025-11-08T17:29:55.121689Z",
        "freshness": 0.0
      },
      "so-2025-11-08-032": {
        "title": "Inheritance Overview",
        "content": [
          "Inheritance is a mechanism in object-oriented programming that allows a subclass to inherit methods and fields from a superclass, promoting code reuse and polymorphism."
        ],
        "timestamp": "2025-11-08T17:32:04.072026Z",
        "freshness": 0.0
      },
      "so-2025-11-08-033": {
        "title": "Dynamic Dispatch in OOP",
        "content": [
          "Dynamic dispatch determines the method implementations to invoke at runtime based on the dynamic type, enabling polymorphic behavior."
        ],
        "timestamp": "2025-11-08T17:32:04.072026Z",
        "freshness": 0.0
      },
      "so-2025-11-08-034": {
        "title": "Java Inheritance Rules",
        "content": [
          "In Java, subclass methods must have compatible signatures with the superclass, and overridable methods should not throw more exceptions than specified."
        ],
        "timestamp": "2025-11-08T17:32:04.072026Z",
        "freshness": 0.0
      },
      "so-2025-11-08-035": {
        "title": "Software Construction Principles",
        "content": [
          "The document covers principles of software construction including inheritance, delegation, design, and concurrency."
        ],
        "timestamp": "2025-11-08T17:34:39.608807Z",
        "freshness": 0.0
      },
      "so-2025-11-08-036": {
        "title": "Santorini Game Assignment",
        "content": [
          "An assignment regarding the design and implementation of the game Santorini was released, with strict deadlines and peer review requirements mentioned."
        ],
        "timestamp": "2025-11-08T17:34:39.608807Z",
        "freshness": 0.0
      },
      "so-2025-11-08-037": {
        "title": "Modeling Techniques",
        "content": [
          "Discussion on object and interaction diagrams, assigning responsibilities, and design principles like low coupling and high cohesion."
        ],
        "timestamp": "2025-11-08T17:34:39.608807Z",
        "freshness": 0.0
      },
      "so-2025-11-08-038": {
        "title": "Inheritance and Composition",
        "content": [
          "Compares inheritance and composition, detailing how they enable code reuse and their respective trade-offs in software design."
        ],
        "timestamp": "2025-11-08T17:34:39.608807Z",
        "freshness": 0.0
      },
      "so-2025-11-08-039": {
        "title": "Design Patterns: Template vs Strategy",
        "content": [
          "Describes the Template Method and Strategy design patterns, highlighting the use of inheritance and delegation to vary algorithms."
        ],
        "timestamp": "2025-11-08T17:34:39.608807Z",
        "freshness": 0.0
      },
      "so-2025-11-08-040": {
        "title": "Java Inheritance Mechanics",
        "content": [
          "Details various mechanics of Java inheritance, including method overriding, the class hierarchy tree, and how dynamic dispatch works."
        ],
        "timestamp": "2025-11-08T17:40:33.811467Z",
        "freshness": 0.0
      },
      "so-2025-11-08-041": {
        "title": "LoggingList Example",
        "content": [
          "Demonstrates reuse via inheritance using a LoggingList as a subclass of IntArrayList to add functionality, like logging all additions to the list."
        ],
        "timestamp": "2025-11-08T17:40:33.811467Z",
        "freshness": 0.0
      },
      "so-2025-11-08-042": {
        "title": "Payment Card Example",
        "content": [
          "An example showing different design approaches (inheritance vs. composition) for implementing payment cards like CreditCard and DebitCard."
        ],
        "timestamp": "2025-11-08T17:40:33.811467Z",
        "freshness": 0.0
      },
      "so-2025-11-08-043": {
        "title": "Language Enforcement",
        "content": [
          "Explains different enforcement mechanisms for subtyping and inheritance in languages like Java and TypeScript."
        ],
        "timestamp": "2025-11-08T17:40:33.811467Z",
        "freshness": 0.0
      },
      "so-2025-11-08-044": {
        "title": "Abstract Classes and Methods",
        "content": [
          "Details the use of abstract classes and methods as a way to define a template for subtypes in object-oriented programming."
        ],
        "timestamp": "2025-11-08T17:40:33.811467Z",
        "freshness": 0.0
      },
      "so-2025-11-08-045": {
        "title": "Inheritance",
        "content": [
          "Inheritance allows a new class to adopt the properties and methods of an existing class, enabling code reuse and polymorphism. However, it may lead to tight coupling and issues like the fragile base class problem."
        ],
        "timestamp": "2025-11-08T17:44:30.278950Z",
        "freshness": 0.0
      },
      "so-2025-11-08-046": {
        "title": "Class Hierarchies",
        "content": [
          "Class hierarchies organize classes in a tree where a superclass shares its structure and behavior with derived subclasses, promoting systematic reuse and specialization of code."
        ],
        "timestamp": "2025-11-08T17:44:30.278950Z",
        "freshness": 0.0
      },
      "so-2025-11-08-047": {
        "title": "Testing and Subtype Relations",
        "content": [
          "Testing with subclasses is crucial to ensure that subclasses adhere to expected behaviors of their superclasses, maintaining strong subtype relationships and preventing integration issues."
        ],
        "timestamp": "2025-11-08T17:44:30.278950Z",
        "freshness": 0.0
      },
      "so-2025-11-08-048": {
        "title": "Heuristics for Responsibility Assignment",
        "content": [
          "When assigning responsibilities in software design, important heuristics include low representational gap, low coupling, high cohesion, and roles such as controller, information expert, and creator."
        ],
        "timestamp": "2025-11-08T17:55:10.986647Z",
        "freshness": 0.0
      },
      "so-2025-11-08-049": {
        "title": "IntArrayList and LoggingList Example",
        "content": [
          "An IntArrayList is an example of implementing a list for integers, using an array. A LoggingList can extend it to add logging functionality. It highlights inheritance benefits and the fragile base class problem."
        ],
        "timestamp": "2025-11-08T17:55:10.986647Z",
        "freshness": 0.0
      },
      "so-2025-11-08-050": {
        "title": "Coupling and Cohesion in Design",
        "content": [
          "Low coupling and high cohesion are crucial design principles. They ensure that a system is modular and maintainable by reducing dependencies between components and increasing the internal consistency within components."
        ],
        "timestamp": "2025-11-08T17:55:10.986647Z",
        "freshness": 0.0
      },
      "so-2025-11-08-051": {
        "title": "Final Thoughts on Inheritance",
        "content": [
          "Deciding to use inheritance should be done with care, as it can increase coupling. Often, composition + delegation are preferred, but inheritance might be suitable when there is a clear ‘is-a’ relationship."
        ],
        "timestamp": "2025-11-08T17:55:10.986647Z",
        "freshness": 0.0
      },
      "so-2025-11-08-052": {
        "title": "Santorini Game Design",
        "content": [
          "The homework assignment involves the initial design and implementation of the Santorini game core API. Students are instructed to claim their GitHub repository to start the project."
        ],
        "timestamp": "2025-11-08T17:56:37.121649Z",
        "freshness": 0.0
      },
      "so-2025-11-08-053": {
        "title": "Template Method Design Pattern",
        "content": [
          "This pattern leverages inheritance where a superclass defines the template of an algorithm, and subclasses implement specific components. It allows for varying parts of an algorithm through subclassing."
        ],
        "timestamp": "2025-11-08T17:56:37.121649Z",
        "freshness": 0.0
      },
      "so-2025-11-08-054": {
        "title": "Language Enforcement in OOP",
        "content": [
          "Languages like Java and TypeScript include constructs such as `final`, `abstract`, and method overriding to enforce or restrict inheritance behavior, promoting structure and preventing misuse."
        ],
        "timestamp": "2025-11-08T17:56:37.121649Z",
        "freshness": 0.0
      },
      "so-2025-11-08-055": {
        "title": "Delegation for Functionality Extension",
        "content": [
          "Delegation involves one object relying on another to perform certain operations. This approach supports code reuse and flexibility, seen in examples like custom sorting orders and logging functionality."
        ],
        "timestamp": "2025-11-08T17:56:37.121649Z",
        "freshness": 0.0
      },
      "so-2025-11-08-056": {
        "title": "PaymentCard Design Variants",
        "content": [
          "Different design options for implementing payment cards demonstrate the use of both inheritance and composition, showing trade-offs in terms of code reuse, modularity, and structural design."
        ],
        "timestamp": "2025-11-08T17:56:37.121649Z",
        "freshness": 0.0
      }
    },
    "MACHINE_LEARNING": {
      "ml-2025-08-11-001": {
        "title": "In-Class Polls",
        "content": [
          "Students are required to participate in in-class polls via a Google form, providing answers during the lecture for full credit or within 24 hours for half credit. There is a limit on using 'free poll points'."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-002": {
        "title": "Recursive vs. Iterative Search",
        "content": [
          "Decision trees can implement searches recursively or iteratively; both methods ensure efficient navigation through tree nodes to locate target values."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-003": {
        "title": "Decision Stump",
        "content": [
          "A decision stump is a single-level decision tree that predicts outcomes based on a single feature, serving as a simple classifier with potential training errors."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-004": {
        "title": "Decision Tree Prediction",
        "content": [
          "Decision trees predict outcomes by traversing from root to leaf nodes, using features to inform branching decisions, and arriving at a final classification label at the leaf."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-005": {
        "title": "Splitting Criterion in Decision Trees",
        "content": [
          "Effective building of decision trees involves selecting the best splitting attribute using criteria such as error rate, accuracy, mutual information, and Gini gain."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-006": {
        "title": "Entropy",
        "content": [
          "Entropy measures the uncertainty or impurity in a set; higher entropy indicates greater disorder, making it a crucial concept in decision tree splitting."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-007": {
        "title": "Mutual Information",
        "content": [
          "Mutual information quantifies the clarity gained about one random variable by knowing another, helping to determine the best feature splits in decision trees."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      },
      "ml-2025-08-11-008": {
        "title": "Recursive Training for Decision Trees",
        "content": [
          "The recursive training process for decision trees involves constructing nodes by evaluating attributes' effectiveness, leading to either a leaf with a clear label or further splitting."
        ],
        "timestamp": "2025-08-11T00:00:00Z",
        "freshness": 0.76
      }
    }
  }
}